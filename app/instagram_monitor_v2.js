const fs = require('fs').promises;
const path = require('path');
const { spawn } = require('child_process');
const axios = require('axios');

class InstagramMonitorV2 {
    constructor(notificationCallback, config) {
        this.notificationCallback = notificationCallback;
        this.config = config;
        this.isMonitoring = false;
        this.checkInterval = null;
        this.tempDir = '/tmp/instagram_cache';
        
        // Áõ£ÊéßÁãÄÊÖã
        this.state = {
            lastPostId: null,
            lastBio: null,
            lastProfilePic: null,
            totalChecks: 0,
            newPostsFound: 0,
            bioChanges: 0,
            profilePicChanges: 0,
            lastCheck: null,
            nextCheck: null,
            isPrivate: false,
            followerCount: null,
            followingCount: null,
            postCount: null,
            instaloaderInstalled: false
        };

        // Á¢∫‰øùËá®ÊôÇÁõÆÈåÑÂ≠òÂú®
        this.ensureTempDir();
        
        // Ê™¢Êü•‰∏¶ÂÆâË£ù instaloader
        this.setupInstaloader();
    }

    async ensureTempDir() {
        try {
            await fs.mkdir(this.tempDir, { recursive: true });
            console.log(`üìÅ [Instagram] Ëá®ÊôÇÁõÆÈåÑÂ∑≤Âª∫Á´ã: ${this.tempDir}`);
        } catch (error) {
            console.error('‚ùå [Instagram] Ëá®ÊôÇÁõÆÈåÑÂª∫Á´ãÂ§±Êïó:', error.message);
        }
    }

    // ÂÆâË£ùÂíåË®≠ÁΩÆ instaloader
    async setupInstaloader() {
        try {
            console.log('üîß [Instagram] Ê™¢Êü• instaloader ÂÆâË£ùÁãÄÊÖã...');
            
            // Ê™¢Êü• Python ÊòØÂê¶ÂèØÁî®
            const pythonCheck = await this.runCommand('python3', ['--version']);
            if (!pythonCheck.success) {
                console.error('‚ùå [Instagram] Python3 Êú™ÂÆâË£ù');
                console.error('Ë´ãÁ¢∫‰øùÂÆπÂô®‰∏≠ÂÆâË£ù‰∫Ü Python3');
                return;
            }
            console.log(`‚úÖ [Instagram] ${pythonCheck.output}`);

            // Ê™¢Êü• instaloader ÊòØÂê¶Â∑≤ÂÆâË£ù
            const instaloaderCheck = await this.runCommand('python3', ['-c', 'import instaloader; print("instaloader version:", instaloader.__version__)']);
            
            if (instaloaderCheck.success) {
                console.log(`‚úÖ [Instagram] ${instaloaderCheck.output}`);
                this.state.instaloaderInstalled = true;
            } else {
                console.log('üì¶ [Instagram] instaloader Êú™ÂÆâË£ùÔºåÂòóË©¶ÂÆâË£ù...');
                
                // ÂòóË©¶Â§öÁ®ÆÂÆâË£ùÊñπÂºè
                const installMethods = [
                    ['pip3', ['install', '--user', 'instaloader']],
                    ['pip3', ['install', 'instaloader']],
                    ['python3', ['-m', 'pip', 'install', '--user', 'instaloader']],
                    ['python3', ['-m', 'pip', 'install', 'instaloader']]
                ];
                
                let installSuccess = false;
                
                for (const [cmd, args] of installMethods) {
                    console.log(`üîÑ [Instagram] ÂòóË©¶: ${cmd} ${args.join(' ')}`);
                    const installResult = await this.runCommand(cmd, args, { timeout: 120000 });
                    
                    if (installResult.success) {
                        // ÂÜçÊ¨°Ê™¢Êü•ÊòØÂê¶ÂÆâË£ùÊàêÂäü
                        const verifyCheck = await this.runCommand('python3', ['-c', 'import instaloader; print("ÂÆâË£ùÊàêÂäü")']);
                        if (verifyCheck.success) {
                            console.log('‚úÖ [Instagram] instaloader ÂÆâË£ùÊàêÂäü');
                            this.state.instaloaderInstalled = true;
                            installSuccess = true;
                            break;
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è [Instagram] ${cmd} ÂÆâË£ùÂ§±Êïó: ${installResult.error}`);
                    }
                }
                
                if (!installSuccess) {
                    console.error('‚ùå [Instagram] ÊâÄÊúâÂÆâË£ùÊñπÊ≥ïÈÉΩÂ§±Êïó');
                    console.error('Âª∫Ë≠∞Âú® Dockerfile ‰∏≠È†êÂÖàÂÆâË£ù instaloader');
                }
            }

        } catch (error) {
            console.error('‚ùå [Instagram] instaloader Ë®≠ÁΩÆÂ§±Êïó:', error.message);
        }
    }

    // Âü∑Ë°åÂëΩ‰ª§Ë°åÊåá‰ª§
    async runCommand(command, args = [], options = {}) {
        return new Promise((resolve) => {
            const timeout = options.timeout || 30000;
            const child = spawn(command, args, {
                cwd: options.cwd || this.tempDir,
                env: { ...process.env, ...options.env }
            });

            let output = '';
            let error = '';

            child.stdout?.on('data', (data) => {
                output += data.toString();
            });

            child.stderr?.on('data', (data) => {
                error += data.toString();
            });

            const timer = setTimeout(() => {
                child.kill('SIGKILL');
                resolve({
                    success: false,
                    output: output.trim(),
                    error: 'Command timeout'
                });
            }, timeout);

            child.on('close', (code) => {
                clearTimeout(timer);
                resolve({
                    success: code === 0,
                    output: output.trim(),
                    error: error.trim(),
                    code
                });
            });

            child.on('error', (err) => {
                clearTimeout(timer);
                resolve({
                    success: false,
                    output: output.trim(),
                    error: err.message
                });
            });
        });
    }

    // ‰ΩøÁî® instaloader Áç≤ÂèñÁî®Êà∂Ë≥áÊñô
    async fetchInstagramData() {
        if (!this.state.instaloaderInstalled) {
            throw new Error('instaloader Êú™Ê≠£Á¢∫ÂÆâË£ù');
        }

        try {
            const username = this.config.username;
            console.log(`üîç [Instagram] ‰ΩøÁî® instaloader Áç≤Âèñ @${username} ÁöÑÊï∏Êìö...`);
            
            // ÂâµÂª∫ Python ËÖ≥Êú¨‰æÜÁç≤ÂèñÁî®Êà∂Ë≥áÊñô
            const pythonScript = this.generatePythonScript();
            const scriptPath = path.join(this.tempDir, 'fetch_instagram_data.py');
            
            await fs.writeFile(scriptPath, pythonScript);
            
            // Âü∑Ë°å Python ËÖ≥Êú¨
            const result = await this.runCommand('python3', [scriptPath, username], { timeout: 60000 });
            
            if (!result.success) {
                console.error('‚ùå [Instagram] Python ËÖ≥Êú¨Âü∑Ë°åÂ§±Êïó:', result.error);
                throw new Error(result.error || 'Python ËÖ≥Êú¨Âü∑Ë°åÂ§±Êïó');
            }

            // Ëß£Êûê JSON Ëº∏Âá∫
            const userData = JSON.parse(result.output);
            console.log(`‚úÖ [Instagram] Êï∏ÊìöÁç≤ÂèñÊàêÂäü: @${username}`);
            
            return userData;

        } catch (error) {
            console.error('‚ùå [Instagram] Êï∏ÊìöÁç≤ÂèñÂ§±Êïó:', error.message);
            
            if (error.message.includes('429') || error.message.includes('rate limit')) {
                throw new Error('RATE_LIMITED');
            }
            
            throw error;
        }
    }

    // ÁîüÊàê Python ËÖ≥Êú¨
    generatePythonScript() {
        return `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import instaloader
import json
import sys
import os
from datetime import datetime

def fetch_user_data(username):
    try:
        # Âª∫Á´ã instaloader ÂØ¶‰æã
        L = instaloader.Instaloader(
            download_pictures=False,
            download_videos=False,
            download_video_thumbnails=False,
            download_geotags=False,
            download_comments=False,
            save_metadata=False,
            compress_json=False,
            dirname_pattern="{target}",
            filename_pattern="{shortcode}"
        )
        
        # Ë®≠ÁΩÆË´ãÊ±ÇÂª∂ÈÅ≤‰ª•ÈÅøÂÖçË¢´Â∞ÅÈéñ
        L.context.request_timeout = (4, 10)
        
        try:
            # Áç≤ÂèñÁî®Êà∂Ë≥áÊñô
            profile = instaloader.Profile.from_username(L.context, username)
            
            # Áç≤ÂèñÊúÄÊñ∞Ë≤ºÊñá
            posts = []
            post_count = 0
            for post in profile.get_posts():
                if post_count >= 3:  # Âè™ÂèñÂâç3ÁØáË≤ºÊñá
                    break
                
                posts.append({
                    'id': post.mediaid,
                    'shortcode': post.shortcode,
                    'caption': post.caption or '',
                    'display_url': post.url,
                    'is_video': post.is_video,
                    'video_url': post.video_url if post.is_video else None,
                    'timestamp': int(post.date_utc.timestamp()),
                    'like_count': post.likes,
                    'comment_count': post.comments,
                    'typename': post.typename
                })
                post_count += 1
            
            # ÁµÑÁπîÁî®Êà∂Êï∏Êìö
            user_data = {
                'username': profile.username,
                'biography': profile.biography or '',
                'follower_count': profile.followers,
                'following_count': profile.followees,
                'post_count': profile.mediacount,
                'profile_pic_url': profile.profile_pic_url,
                'is_private': profile.is_private,
                'posts': posts,
                'success': True,
                'fetch_time': datetime.now().isoformat()
            }
            
            return user_data
            
        except instaloader.exceptions.ProfileNotExistsException:
            return {
                'success': False,
                'error': f'Áî®Êà∂ @{username} ‰∏çÂ≠òÂú®',
                'error_type': 'ProfileNotExists'
            }
        except instaloader.exceptions.LoginRequiredException:
            return {
                'success': False,
                'error': 'Ê≠§Áî®Êà∂ÁÇ∫ÁßÅ‰∫∫Â∏≥Êà∂ÔºåÈúÄË¶ÅÁôªÂÖ•',
                'error_type': 'LoginRequired'
            }
        except instaloader.exceptions.ConnectionException as e:
            return {
                'success': False,
                'error': f'ÈÄ£Êé•ÈåØË™§: {str(e)}',
                'error_type': 'ConnectionError'
            }
        except instaloader.exceptions.TooManyRequestsException:
            return {
                'success': False,
                'error': 'Ë´ãÊ±ÇÈÅéÊñºÈ†ªÁπÅÔºåË´ãÁ®çÂæåÂÜçË©¶',
                'error_type': 'RateLimit'
            }
            
    except Exception as e:
        return {
            'success': False,
            'error': f'Êú™Áü•ÈåØË™§: {str(e)}',
            'error_type': 'Unknown'
        }

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print(json.dumps({
            'success': False,
            'error': '‰ΩøÁî®ÊñπÂºè: python3 fetch_instagram_data.py <username>'
        }))
        sys.exit(1)
    
    username = sys.argv[1]
    result = fetch_user_data(username)
    print(json.dumps(result, ensure_ascii=False, indent=None))
`;
    }

    // ‰∏ãËºâÂ™íÈ´îÊ™îÊ°à
    async downloadMedia(url, filename) {
        try {
            const response = await axios({
                method: 'GET',
                url: url,
                responseType: 'stream',
                timeout: 30000,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                }
            });

            const filePath = path.join(this.tempDir, filename);
            const writer = require('fs').createWriteStream(filePath);
            
            response.data.pipe(writer);

            return new Promise((resolve, reject) => {
                writer.on('finish', () => resolve(filePath));
                writer.on('error', reject);
            });
        } catch (error) {
            console.error(`‚ùå [Instagram] Â™íÈ´î‰∏ãËºâÂ§±Êïó: ${error.message}`);
            throw error;
        }
    }

    // Ê∏ÖÁêÜËá®ÊôÇÊ™îÊ°à
    async cleanupTempFiles() {
        try {
            const files = await fs.readdir(this.tempDir);
            let cleanedCount = 0;
            
            for (const file of files) {
                const filePath = path.join(this.tempDir, file);
                const stats = await fs.stat(filePath);
                
                // Âà™Èô§Ë∂ÖÈÅé1Â∞èÊôÇÁöÑÊ™îÊ°àÔºåÊàñÊòØ .py ËÖ≥Êú¨Ê™îÊ°à
                const isOld = (Date.now() - stats.mtime.getTime()) > 3600000;
                const isPythonScript = file.endsWith('.py');
                const isMediaFile = file.match(/\.(jpg|jpeg|png|mp4|mov)$/i);
                
                if (isOld || isPythonScript || isMediaFile) {
                    await fs.unlink(filePath);
                    cleanedCount++;
                }
            }
            
            if (cleanedCount > 0) {
                console.log(`üßπ [Instagram] Â∑≤Ê∏ÖÁêÜ ${cleanedCount} ÂÄãËá®ÊôÇÊ™îÊ°à`);
            }
        } catch (error) {
            console.error('‚ùå [Instagram] Ê∏ÖÁêÜËá®ÊôÇÊ™îÊ°àÂ§±Êïó:', error.message);
        }
    }

    // Âà™Èô§ÂñÆÂÄãÊ™îÊ°à
    async deleteFile(filePath) {
        try {
            await fs.unlink(filePath);
            console.log(`üóëÔ∏è [Instagram] Â∑≤Âà™Èô§Ê™îÊ°à: ${path.basename(filePath)}`);
        } catch (error) {
            console.error(`‚ùå [Instagram] Ê™îÊ°àÂà™Èô§Â§±Êïó: ${error.message}`);
        }
    }

    // Ê™¢Êü•Êñ∞Ë≤ºÊñá
    async checkForNewPosts(userData) {
        if (!userData.posts || userData.posts.length === 0) {
            console.log(`üìã [Instagram] ÁÑ°Ë≤ºÊñáÊï∏ÊìöÂèØÊ™¢Êü•`);
            return null;
        }

        const latestPost = userData.posts[0];
        console.log(`üîç [Instagram] Ê™¢Êü•ÊúÄÊñ∞Ë≤ºÊñá: ${latestPost.shortcode}`);
        
        if (this.state.lastPostId && this.state.lastPostId !== latestPost.id) {
            this.state.newPostsFound++;
            this.state.lastPostId = latestPost.id;
            
            console.log(`üì∏ [Instagram] ÁôºÁèæÊñ∞Ë≤ºÊñá: ${latestPost.shortcode}`);
            
            // ‰∏ãËºâÂ™íÈ´î‰∏¶ÁôºÈÄÅÈÄöÁü•
            await this.handleNewPost(latestPost);
            
            return latestPost;
        }

        // ÂàùÂßãÂåñÁãÄÊÖã
        if (!this.state.lastPostId) {
            this.state.lastPostId = latestPost.id;
            console.log(`üéØ [Instagram] ÂàùÂßãÂåñÊúÄÊñ∞Ë≤ºÊñáID: ${latestPost.shortcode}`);
        }

        return null;
    }

    // ËôïÁêÜÊñ∞Ë≤ºÊñá
    async handleNewPost(post) {
        const mediaFiles = [];
        
        try {
            // ‰∏ãËºâ‰∏ªË¶ÅÂúñÁâá/ÂΩ±Áâá
            if (post.display_url) {
                const extension = post.is_video ? 'mp4' : 'jpg';
                const filename = `${post.shortcode}_${Date.now()}.${extension}`;
                const downloadedFile = await this.downloadMedia(post.display_url, filename);
                mediaFiles.push(downloadedFile);
                console.log(`üì• [Instagram] Â∑≤‰∏ãËºâ ${post.is_video ? 'ÂΩ±Áâá' : 'ÂúñÁâá'}: ${filename}`);
            }

            // ÁôºÈÄÅÈÄöÁü•
            await this.sendPostNotification(post, mediaFiles);

        } catch (error) {
            console.error('‚ùå [Instagram] Êñ∞Ë≤ºÊñáËôïÁêÜÂ§±Êïó:', error.message);
        } finally {
            // ÁÑ°Ë´ñÊàêÂäüÈÇÑÊòØÂ§±ÊïóÔºåÈÉΩË¶ÅÊ∏ÖÁêÜÊ™îÊ°à
            for (const file of mediaFiles) {
                await this.deleteFile(file);
            }
        }
    }

    // Ê™¢Êü•BioËÆäÊõ¥
    async checkBioChange(userData) {
        const newBio = userData.biography || '';
        
        if (this.state.lastBio && this.state.lastBio !== newBio) {
            this.state.bioChanges++;
            const oldBio = this.state.lastBio;
            this.state.lastBio = newBio;
            
            console.log(`üìù [Instagram] ÁôºÁèæBioËÆäÊõ¥`);
            await this.sendBioChangeNotification(oldBio, newBio);
            
            return { oldBio, newBio };
        }

        if (!this.state.lastBio && newBio.length > 0) {
            this.state.lastBio = newBio;
            console.log(`üéØ [Instagram] ÂàùÂßãÂåñBio: "${newBio.substring(0, 30)}..."`);
        }

        return null;
    }

    // Ê™¢Êü•È†≠ÂÉèËÆäÊõ¥
    async checkProfilePicChange(userData) {
        const newProfilePic = userData.profile_pic_url || '';
        
        if (newProfilePic.length < 10) return null;
        
        if (this.state.lastProfilePic && this.state.lastProfilePic !== newProfilePic) {
            this.state.profilePicChanges++;
            const oldPicUrl = this.state.lastProfilePic;
            this.state.lastProfilePic = newProfilePic;
            
            console.log(`üñºÔ∏è [Instagram] ÁôºÁèæÈ†≠ÂÉèËÆäÊõ¥`);
            
            try {
                const picFilename = `profile_pic_${Date.now()}.jpg`;
                const downloadedPic = await this.downloadMedia(newProfilePic, picFilename);
                await this.sendProfilePicChangeNotification(downloadedPic);
                await this.deleteFile(downloadedPic);
            } catch (error) {
                console.error('‚ùå [Instagram] È†≠ÂÉèËôïÁêÜÂ§±Êïó:', error.message);
            }
            
            return { oldUrl: oldPicUrl, newUrl: newProfilePic };
        }

        if (!this.state.lastProfilePic && newProfilePic.length > 10) {
            this.state.lastProfilePic = newProfilePic;
            console.log(`üéØ [Instagram] ÂàùÂßãÂåñÈ†≠ÂÉèURL`);
        }

        return null;
    }

    // ÁôºÈÄÅË≤ºÊñáÈÄöÁü•
    async sendPostNotification(post, mediaFiles) {
        const postDate = new Date(post.timestamp * 1000);
        const message = `üì∏ **Instagram Êñ∞Ë≤ºÊñáÈÄöÁü•**

üë§ **Áî®Êà∂:** @${this.config.username}
üÜî **Ë≤ºÊñáID:** ${post.shortcode}
‚è∞ **ÁôºÂ∏ÉÊôÇÈñì:** ${postDate.toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}
‚ù§Ô∏è **ËÆöÊï∏:** ${post.like_count || 0}
üí¨ **ÁïôË®ÄÊï∏:** ${post.comment_count || 0}
üé• **È°ûÂûã:** ${post.is_video ? 'ÂΩ±Áâá' : 'ÁÖßÁâá'}

üìù **ÂÖßÂÆπ:**
${post.caption ? post.caption.substring(0, 500) + (post.caption.length > 500 ? '...' : '') : 'ÁÑ°ÊñáÂ≠óÂÖßÂÆπ'}

üîó **ÈÄ£Áµê:** https://www.instagram.com/p/${post.shortcode}/`;

        await this.notificationCallback(message, 'new_post', 'Instagram', mediaFiles);
    }

    // ÁôºÈÄÅBioËÆäÊõ¥ÈÄöÁü•
    async sendBioChangeNotification(oldBio, newBio) {
        const message = `üìù **Instagram Bio ËÆäÊõ¥ÈÄöÁü•**

üë§ **Áî®Êà∂:** @${this.config.username}
‚è∞ **ËÆäÊõ¥ÊôÇÈñì:** ${new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}

**üî¥ ËàäBio:**
${oldBio || '(Á©∫ÁôΩ)'}

**üü¢ Êñ∞Bio:**
${newBio || '(Á©∫ÁôΩ)'}`;

        await this.notificationCallback(message, 'bio_change', 'Instagram');
    }

    // ÁôºÈÄÅÈ†≠ÂÉèËÆäÊõ¥ÈÄöÁü•
    async sendProfilePicChangeNotification(picFilePath) {
        const message = `üñºÔ∏è **Instagram È†≠ÂÉèËÆäÊõ¥ÈÄöÁü•**

üë§ **Áî®Êà∂:** @${this.config.username}
‚è∞ **ËÆäÊõ¥ÊôÇÈñì:** ${new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}

üì∑ **Êñ∞È†≠ÂÉèÂ∑≤‰∏ãËºâ (Â∞áÂú®ÁôºÈÄÅÂæåÂà™Èô§)**`;

        await this.notificationCallback(message, 'profile_pic_change', 'Instagram', [picFilePath]);
    }

    // ‰∏ªÊ™¢Êü•ÂáΩÊï∏
    async performCheck() {
        try {
            this.state.totalChecks++;
            this.state.lastCheck = new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
            
            console.log(`üîç [Instagram] ÈñãÂßãÊ™¢Êü• @${this.config.username} (Á¨¨${this.state.totalChecks}Ê¨°)`);

            const userData = await this.fetchInstagramData();
            
            if (!userData.success) {
                console.error(`‚ùå [Instagram] Êï∏ÊìöÁç≤ÂèñÂ§±Êïó: ${userData.error}`);
                
                if (userData.error_type === 'RateLimit') {
                    throw new Error('RATE_LIMITED');
                } else if (userData.error_type === 'LoginRequired') {
                    console.warn('‚ö†Ô∏è [Instagram] Áî®Êà∂ÁÇ∫ÁßÅ‰∫∫Â∏≥Êà∂ÔºåÁÑ°Ê≥ïÁõ£Êéß');
                    return;
                }
                
                throw new Error(userData.error);
            }
            
            // Êõ¥Êñ∞Âü∫Êú¨Áµ±Ë®à
            this.state.isPrivate = userData.is_private;
            this.state.followerCount = userData.follower_count;
            this.state.followingCount = userData.following_count;
            this.state.postCount = userData.post_count;

            // Ê™¢Êü•ÂêÑÁ®ÆËÆäÊõ¥
            const newPost = await this.checkForNewPosts(userData);
            const bioChange = await this.checkBioChange(userData);
            const picChange = await this.checkProfilePicChange(userData);

            // Ê∏ÖÁêÜËá®ÊôÇÊ™îÊ°à
            await this.cleanupTempFiles();

            console.log(`‚úÖ [Instagram] Ê™¢Êü•ÂÆåÊàê @${this.config.username}`);
            
        } catch (error) {
            console.error(`‚ùå [Instagram] Ê™¢Êü•Â§±Êïó: ${error.message}`);
            
            if (error.message === 'RATE_LIMITED') {
                console.warn('‚è∏Ô∏è [Instagram] Âõ†ÈÄüÁéáÈôêÂà∂Êö´ÂÅúÁõ£Êéß30ÂàÜÈêò');
                this.pauseMonitoring(30 * 60 * 1000);
            }
        }
    }

    // Êö´ÂÅúÁõ£Êéß
    pauseMonitoring(duration) {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
            this.checkInterval = null;
        }

        setTimeout(() => {
            if (this.isMonitoring) {
                this.startMonitoring();
                console.log('‚ñ∂Ô∏è [Instagram] Áõ£ÊéßÂ∑≤ÊÅ¢Âæ©');
            }
        }, duration);
    }

    // ÈñãÂßãÁõ£Êéß
    startMonitoring() {
        if (this.isMonitoring) {
            console.warn('‚ö†Ô∏è [Instagram] Áõ£ÊéßÂ∑≤Âú®ÈÅãË°å‰∏≠');
            return;
        }

        if (!this.state.instaloaderInstalled) {
            console.error('‚ùå [Instagram] instaloader Êú™ÂÆâË£ùÔºåÁÑ°Ê≥ïÂïüÂãïÁõ£Êéß');
            return;
        }

        this.isMonitoring = true;
        const checkInterval = this.config.checkInterval || 5 * 60 * 1000;
        
        this.checkInterval = setInterval(() => {
            this.performCheck();
        }, checkInterval);

        // Á´ãÂç≥Âü∑Ë°å‰∏ÄÊ¨°Ê™¢Êü•
        this.performCheck();

        console.log(`üöÄ [Instagram] ÈñãÂßãÁõ£Êéß @${this.config.username}`);
        console.log(`‚è∞ [Instagram] Ê™¢Êü•ÈñìÈöî: ${checkInterval / 60000} ÂàÜÈêò`);
        console.log(`üõ†Ô∏è [Instagram] ‰ΩøÁî® instaloader ÂºïÊìé`);
    }

    // ÂÅúÊ≠¢Áõ£Êéß
    stopMonitoring() {
        if (!this.isMonitoring) return;

        this.isMonitoring = false;
        
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
            this.checkInterval = null;
        }

        this.cleanupTempFiles();
        console.log(`üõë [Instagram] Â∑≤ÂÅúÊ≠¢Áõ£Êéß @${this.config.username}`);
    }

    // Áç≤ÂèñÁãÄÊÖã
    getStatus() {
        const checkIntervalMinutes = this.config.checkInterval ? this.config.checkInterval / 60000 : 5;
        
        return {
            isMonitoring: this.isMonitoring,
            username: this.config.username,
            totalChecks: this.state.totalChecks,
            newPostsFound: this.state.newPostsFound,
            bioChanges: this.state.bioChanges,
            profilePicChanges: this.state.profilePicChanges,
            lastCheck: this.state.lastCheck,
            nextCheck: this.isMonitoring ? 
                new Date(Date.now() + (this.config.checkInterval || 5 * 60 * 1000)).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) : 
                null,
            checkInterval: `${checkIntervalMinutes} ÂàÜÈêò`,
            isPrivate: this.state.isPrivate,
            followerCount: this.state.followerCount,
            followingCount: this.state.followingCount,
            postCount: this.state.postCount,
            storageUsage: 'KoyebËá®ÊôÇÂ≠òÂÑ≤ (Ëá™ÂãïÊ∏ÖÁêÜ)',
            instaloaderInstalled: this.state.instaloaderInstalled,
            engine: 'instaloader'
        };
    }

    // Ê∏¨Ë©¶ÈÄ£Êé•
    async testConnection() {
        try {
            console.log(`üîç [Instagram] Ê∏¨Ë©¶ÈÄ£Êé• @${this.config.username}...`);
            
            if (!this.state.instaloaderInstalled) {
                return {
                    success: false,
                    username: this.config.username,
                    error: 'instaloader Êú™Ê≠£Á¢∫ÂÆâË£ù'
                };
            }
            
            const userData = await this.fetchInstagramData();
            
            if (!userData.success) {
                return {
                    success: false,
                    username: this.config.username,
                    error: userData.error,
                    error_type: userData.error_type
                };
            }
            
            return {
                success: true,
                username: this.config.username,
                isPrivate: userData.is_private,
                followerCount: userData.follower_count,
                postCount: userData.post_count,
                hasRecentPosts: userData.posts && userData.posts.length > 0,
                latestPostId: userData.posts?.[0]?.shortcode || null,
                bio: userData.biography?.substring(0, 100) || 'ÁÑ°Bio',
                engine: 'instaloader'
            };
        } catch (error) {
            return {
                success: false,
                username: this.config.username,
                error: error.message
            };
        }
    }
}

module.exports = InstagramMonitorV2;